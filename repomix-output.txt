This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.bolt/
  config.json
config/
  index.js
controllers/
  cardController.js
  deckController.js
  inventoryController.js
  userController.js
middleware/
  auth.js
models/
  db.js
  index.js
repositories/
  cardRepository.js
  deckRepository.js
  inventoryRepository.js
  userRepository.js
routes/
  cardRoutes.js
  deckRoutes.js
  index.js
  inventoryRoutes.js
  userRoutes.js
services/
  authService.js
  cardService.js
  deckService.js
  inventoryService.js
  userService.js
.gitignore
index.js
package.json

================================================================
Files
================================================================

================
File: .bolt/config.json
================
{
  "template": "node"
}

================
File: config/index.js
================
require('dotenv').config();

module.exports = {
  PORT: process.env.PORT || 8080,
  JWT_SECRET: process.env.JWT_SECRET || 'magic-inventory-secret-key',
  JWT_EXPIRY: '24h',
  DB: {
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME
  }
};

================
File: controllers/cardController.js
================
const axios = require('axios');
const NodeCache = require('node-cache');
const { pool } = require('../models/db');

// Cache for storing search results
const searchCache = new NodeCache({ stdTTL: 600 }); // 10 minutes TTL
const CARDS_PER_PAGE = 12;
const REQUEST_DELAY_MS = 100;

// Helper function to delay requests to avoid rate limiting
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// Get card types and sets for search filters
const getSearchFilters = async (req, res) => {
  try {
    // Get card types
    await delay(REQUEST_DELAY_MS);
    const cardTypesResponse = await axios.get(
      'https://api.scryfall.com/catalog/card-types'
    );
    const cardTypes = cardTypesResponse.data.data || [];

    // Get sets
    await delay(REQUEST_DELAY_MS);
    const setsResponse = await axios.get('https://api.scryfall.com/sets');
    const sets = setsResponse.data.data || [];

    return res.json({
      cardTypes,
      sets,
    });
  } catch (error) {
    console.error('Error fetching search filters:', error.message);

    if (error.response && error.response.status === 429) {
      return res
        .status(429)
        .json({ error: 'Rate limit exceeded. Please try again later.' });
    }

    return res
      .status(500)
      .json({ error: 'Error fetching data from Scryfall API' });
  }
};

// Search for cards based on filters
const searchCards = async (req, res) => {
  try {
    const { query, type, set, color, rarity, isLegendary, isLand } = req.query;

    // Build search URL
    let urlBuilder = 'https://api.scryfall.com/cards/search?q=';

    if (query && query.trim()) urlBuilder += query.trim();
    if (type) urlBuilder += `+t:${type}`;
    if (set) urlBuilder += `+e:${set}`;
    if (color) urlBuilder += `+c:${color}`;

    // Process multiple rarity values
    if (rarity && Array.isArray(rarity) && rarity.length > 0) {
      urlBuilder += '+(';
      rarity.forEach((r, index) => {
        urlBuilder += `r:${r}`;
        if (index !== rarity.length - 1) {
          urlBuilder += '+or+';
        }
      });
      urlBuilder += ')';
    } else if (rarity && !Array.isArray(rarity)) {
      urlBuilder += `+r:${rarity}`;
    }

    if (isLegendary === 'true') urlBuilder += '+t:legendary';
    if (isLand === 'true') {
      if (color) urlBuilder += `+id:${color}`;
      urlBuilder += '+t:land';
    }

    // Check if we have cached results
    const cacheKey = urlBuilder;
    const cachedResults = searchCache.get(cacheKey);

    if (cachedResults) {
      return res.json({ cards: cachedResults });
    }

    // Make API request if not cached
    await delay(REQUEST_DELAY_MS);
    const response = await axios.get(urlBuilder);

    // Process and format cards
    const cards = response.data.data.map((cardData) =>
      createCardFromResponseData(cardData)
    );

    // Cache the results
    searchCache.set(cacheKey, cards);

    // Calculate pagination
    const page = parseInt(req.query.page) || 1;
    const totalCards = cards.length;
    const totalPages = Math.ceil(totalCards / CARDS_PER_PAGE);
    const start = (page - 1) * CARDS_PER_PAGE;
    const end = Math.min(start + CARDS_PER_PAGE, totalCards);

    return res.json({
      cards: cards.slice(start, end),
      pagination: {
        totalCards,
        totalPages,
        currentPage: page,
        cardsPerPage: CARDS_PER_PAGE,
      },
    });
  } catch (error) {
    console.error('Error searching cards:', error.message);

    if (error.response && error.response.status === 429) {
      return res
        .status(429)
        .json({ error: 'Rate limit exceeded. Please try again later.' });
    }

    return res
      .status(500)
      .json({ error: 'Error searching cards from Scryfall API' });
  }
};

// Get paginated search results
const getPaginatedResults = async (req, res) => {
  try {
    const { sessionId, page = 1 } = req.params;

    // Get cached cards for this session
    const cachedCards = searchCache.get(sessionId);

    if (!cachedCards || cachedCards.length === 0) {
      return res
        .status(404)
        .json({ error: 'No search results found. Please perform a search.' });
    }

    // Calculate pagination
    const totalCards = cachedCards.length;
    const totalPages = Math.ceil(totalCards / CARDS_PER_PAGE);
    const start = (parseInt(page) - 1) * CARDS_PER_PAGE;
    const end = Math.min(start + CARDS_PER_PAGE, totalCards);

    return res.json({
      cards: cachedCards.slice(start, end),
      pagination: {
        totalCards,
        totalPages,
        currentPage: parseInt(page),
        cardsPerPage: CARDS_PER_PAGE,
      },
    });
  } catch (error) {
    console.error('Error getting paginated results:', error.message);
    return res
      .status(500)
      .json({ error: 'Error retrieving paginated results' });
  }
};
const axios = require('axios');
const NodeCache = require('node-cache');
const cardRepository = require('../repositories/cardRepository');
const inventoryRepository = require('../repositories/inventoryRepository');

// Rest of your code...

// Get card by ID
const getCardById = async (req, res) => {
  try {
    const { cardId } = req.params;

    // First check if card exists in our database
    const card = await cardRepository.findById(cardId);

    if (card) {
      return res.json(card);
    }

    // If not in database, fetch from Scryfall API
    await delay(REQUEST_DELAY_MS);
    const response = await axios.get(
      `https://api.scryfall.com/cards/${cardId}`
    );
    const newCard = createCardFromResponseData(response.data);

    // Save card to database for future use
    await cardRepository.save(newCard);

    return res.json(newCard);
  } catch (error) {
    console.error('Error getting card by ID:', error.message);
    return res.status(500).json({ error: 'Error fetching card data' });
  }
};

// Add card to user's inventory
const addCardToInventory = async (req, res) => {
  try {
    const { cardId } = req.body;
    const userId = req.user.id;

    if (!cardId) {
      return res.status(400).json({ error: 'Card ID is required' });
    }

    // Check if user exists
    const userRepository = require('../repositories/userRepository');
    const user = await userRepository.findById(userId);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Check if card exists in our database
    let card = await cardRepository.findById(cardId);

    // If card doesn't exist in our database, fetch it from Scryfall API
    if (!card) {
      try {
        await delay(REQUEST_DELAY_MS);
        const response = await axios.get(
          `https://api.scryfall.com/cards/${cardId}`
        );
        card = createCardFromResponseData(response.data);

        // Save card to database
        await cardRepository.save(card);
      } catch (error) {
        return res.status(404).json({ error: 'Card not found' });
      }
    }

    // Add card to user's inventory
    const inventoryCard = await inventoryRepository.addCard(
      userId,
      cardId,
      card.name,
      card.set_name,
      card.usd
    );

    return res.status(201).json({
      message: 'Card added to inventory successfully',
      card,
      inventoryCard,
    });
  } catch (error) {
    console.error('Error adding card to inventory:', error.message);
    return res.status(500).json({ error: 'Error adding card to inventory' });
  }
};

// Other controller methods...
// Helper function to create card object from API response
function createCardFromResponseData(cardData) {
  const card = {
    id: cardData.id,
    name: cardData.name,
    mana_cost: cardData.mana_cost,
    type_line: cardData.type_line,
    oracle_text: cardData.oracle_text,
    usd: cardData.prices?.usd || null,
    usd_foil: cardData.prices?.usd_foil || null,
    image_url: cardData.image_uris?.normal || null,
    set_name: cardData.set_name || null,
  };

  // Log warning if card ID is null
  if (!card.id) {
    console.warn('Warning: Card ID is null for card:', cardData.name);
  }

  return card;
}

// Helper function to save card to database
async function saveCardToDatabase(card) {
  try {
    await pool.execute(
      `INSERT INTO cards 
       (id, name, mana_cost, type_line, oracle_text, usd, usd_foil, image_url, set_name) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
       ON DUPLICATE KEY UPDATE
       name = VALUES(name),
       mana_cost = VALUES(mana_cost),
       type_line = VALUES(type_line),
       oracle_text = VALUES(oracle_text),
       usd = VALUES(usd),
       usd_foil = VALUES(usd_foil),
       image_url = VALUES(image_url),
       set_name = VALUES(set_name)`,
      [
        card.id,
        card.name,
        card.mana_cost,
        card.type_line,
        card.oracle_text,
        card.usd,
        card.usd_foil,
        card.image_url,
        card.set_name,
      ]
    );
  } catch (error) {
    console.error('Error saving card to database:', error.message);
    throw error;
  }
}

// In cardController.js, add these helper functions:

function isLegendary(typeLine) {
  return typeLine && typeLine.toLowerCase().includes('legendary');
}

function isLand(typeLine) {
  return typeLine && typeLine.toLowerCase().includes('land');
}

// Then update your createCardFromResponseData function to use these:
function createCardFromResponseData(cardData) {
  const card = {
    id: cardData.id,
    name: cardData.name,
    mana_cost: cardData.mana_cost,
    type_line: cardData.type_line,
    oracle_text: cardData.oracle_text,
    usd: cardData.prices?.usd || null,
    usd_foil: cardData.prices?.usd_foil || null,
    image_url: cardData.image_uris?.normal || null,
    set_name: cardData.set_name || null,
    isLegendary: isLegendary(cardData.type_line),
    isLand: isLand(cardData.type_line),
  };

  // Log warning if card ID is null
  if (!card.id) {
    console.warn('Warning: Card ID is null for card:', cardData.name);
  }

  return card;
}

module.exports = {
  getSearchFilters,
  searchCards,
  getPaginatedResults,
  getCardById,
  addCardToInventory,
};

================
File: controllers/deckController.js
================
const { pool } = require('../models/db');
const multer = require('multer');
const upload = multer({ storage: multer.memoryStorage() });

// View a specific deck
const viewDeck = async (req, res) => {
  try {
    const { deckId } = req.params;
    const userId = req.user.id;

    // Get deck information
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    const deck = deckRows[0];

    // Get cards in the deck
    const [deckCardRows] = await pool.execute(
      `SELECT dc.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
       FROM deck_cards dc
       JOIN cards c ON dc.card_id = c.id
       WHERE dc.deck_id = ?`,
      [deckId]
    );

    // Format deck cards
    const deckCards = deckCardRows.map((row) => ({
      id: row.id,
      cardId: row.card_id,
      count: row.count,
      card: {
        id: row.card_id,
        name: row.name,
        manaCost: row.mana_cost,
        typeLine: row.type_line,
        oracleText: row.oracle_text,
        usd: row.usd,
        usdFoil: row.usd_foil,
        imageUrl: row.image_url,
        setName: row.set_name,
      },
    }));

    // Convert picture to base64 if available
    let base64Picture = null;
    if (deck.picture) {
      base64Picture = deck.picture.toString('base64');
    }

    return res.json({
      deck: {
        id: deck.id,
        name: deck.name,
        userId: deck.user_id,
        picture: base64Picture,
        deckCards: deckCards,
      },
    });
  } catch (error) {
    console.error('Error viewing deck:', error.message);
    return res.status(500).json({ error: 'Error retrieving deck information' });
  }
};

// Filter deck cards by color and type
const filterDeckCards = async (req, res) => {
  try {
    const { deckId } = req.params;
    const { color, type } = req.query;
    const userId = req.user.id;

    // Verify deck belongs to user
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    // Build query to filter cards
    let query = `
      SELECT dc.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
      FROM deck_cards dc
      JOIN cards c ON dc.card_id = c.id
      WHERE dc.deck_id = ?
    `;

    const params = [deckId];

    if (color) {
      query += ' AND c.mana_cost LIKE ?';
      params.push(`%${color}%`);
    }

    if (type) {
      query += ' AND c.type_line LIKE ?';
      params.push(`%${type}%`);
    }

    const [deckCardRows] = await pool.execute(query, params);

    // Format deck cards
    const filteredCards = deckCardRows.map((row) => ({
      id: row.id,
      cardId: row.card_id,
      count: row.count,
      card: {
        id: row.card_id,
        name: row.name,
        manaCost: row.mana_cost,
        typeLine: row.type_line,
        oracleText: row.oracle_text,
        usd: row.usd,
        usdFoil: row.usd_foil,
        imageUrl: row.image_url,
        setName: row.set_name,
      },
    }));

    return res.json({ deckCards: filteredCards });
  } catch (error) {
    console.error('Error filtering deck cards:', error.message);
    return res.status(500).json({ error: 'Error filtering deck cards' });
  }
};

// Add a card to a deck (increment count if it exists)
const addCardToDeckHelper = async (deckId, cardId) => {
  // Check if card already exists in deck
  const [existingCardRows] = await pool.execute(
    'SELECT * FROM deck_cards WHERE deck_id = ? AND card_id = ?',
    [deckId, cardId]
  );

  if (existingCardRows.length > 0) {
    // Increment count if card already exists in deck
    await pool.execute(
      'UPDATE deck_cards SET count = count + 1 WHERE deck_id = ? AND card_id = ?',
      [deckId, cardId]
    );
    return { added: true, isNew: false };
  } else {
    // Add new card to deck
    await pool.execute(
      'INSERT INTO deck_cards (deck_id, card_id, count) VALUES (?, ?, 1)',
      [deckId, cardId]
    );
    return { added: true, isNew: true };
  }
};

// Add a card to a deck
const addCardToDeck = async (req, res) => {
  try {
    const { cardId, deckId } = req.body;
    const userId = req.user.id;

    if (!cardId || !deckId) {
      return res
        .status(400)
        .json({ error: 'Card ID and Deck ID are required' });
    }

    // Verify deck belongs to user
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    // Check if card exists
    const [cardRows] = await pool.execute('SELECT * FROM cards WHERE id = ?', [
      cardId,
    ]);

    if (cardRows.length === 0) {
      return res.status(404).json({ error: 'Card not found' });
    }

    // Add card to deck using helper function
    const result = await addCardToDeckHelper(deckId, cardId);

    return res.status(201).json({
      message: 'Card added to deck successfully',
      card: cardRows[0],
      isNewAddition: result.isNew,
    });
  } catch (error) {
    console.error('Error adding card to deck:', error.message);
    return res.status(500).json({ error: 'Error adding card to deck' });
  }
};

// Remove a card from a deck (decrement count if more than 1)
const removeCardFromDeckHelper = async (deckId, cardId) => {
  // Check card count in deck
  const [countResult] = await pool.execute(
    'SELECT count FROM deck_cards WHERE deck_id = ? AND card_id = ?',
    [deckId, cardId]
  );

  if (countResult.length === 0) {
    return { removed: false, reason: 'Card not found in deck' };
  }

  const count = countResult[0].count;

  if (count > 1) {
    // Decrement count if more than 1
    await pool.execute(
      'UPDATE deck_cards SET count = count - 1 WHERE deck_id = ? AND card_id = ?',
      [deckId, cardId]
    );
    return { removed: true, isRemoved: false };
  } else {
    // Remove card from deck
    await pool.execute(
      'DELETE FROM deck_cards WHERE deck_id = ? AND card_id = ?',
      [deckId, cardId]
    );
    return { removed: true, isRemoved: true };
  }
};

// Create a new deck
const createDeck = async (req, res) => {
  try {
    const { name = 'New Deck' } = req.body;
    const userId = req.user.id;

    // Create new deck
    const [result] = await pool.execute(
      'INSERT INTO decks (name, user_id, created_at) VALUES (?, ?, NOW())',
      [name, userId]
    );

    const deckId = result.insertId;

    return res.status(201).json({
      message: 'Deck created successfully',
      deck: {
        id: deckId,
        name,
        userId,
      },
    });
  } catch (error) {
    console.error('Error creating deck:', error.message);
    return res.status(500).json({ error: 'Error creating deck' });
  }
};

// Remove a card from a deck
const removeCardFromDeck = async (req, res) => {
  try {
    const { deckId } = req.params;
    const { cardId } = req.body;
    const userId = req.user.id;

    if (!cardId) {
      return res.status(400).json({ error: 'Card ID is required' });
    }

    // Verify deck belongs to user
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    // Remove card from deck using helper function
    const result = await removeCardFromDeckHelper(deckId, cardId);

    if (!result.removed) {
      return res.status(404).json({ error: result.reason });
    }

    return res.json({
      message: 'Card updated in deck successfully',
      completelyRemoved: result.isRemoved,
    });
  } catch (error) {
    console.error('Error removing card from deck:', error.message);
    return res.status(500).json({ error: 'Error removing card from deck' });
  }
};

// Verify if a deck has at least 5 cards
const verifyDeck = async (req, res) => {
  try {
    const { deckId } = req.params;
    const userId = req.user.id;

    // Verify deck belongs to user
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    // Count total cards in deck
    const [countResult] = await pool.execute(
      'SELECT SUM(count) as total FROM deck_cards WHERE deck_id = ?',
      [deckId]
    );

    const totalCards = countResult[0].total || 0;
    const isValid = totalCards >= 5;

    return res.json({
      isValid,
      totalCards,
      message: isValid
        ? 'Deck is valid. It has at least 5 cards.'
        : 'Deck is invalid. It must have at least 5 cards.',
    });
  } catch (error) {
    console.error('Error verifying deck:', error.message);
    return res.status(500).json({ error: 'Error verifying deck' });
  }
};

// Search for cards within a deck
const searchDeck = async (req, res) => {
  try {
    const { deckId } = req.params;
    const { query, color, type, isLegendary, isLand } = req.query;
    const userId = req.user.id;

    // Verify deck belongs to user
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    // Build query to search cards in deck
    let sqlQuery = `
      SELECT dc.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
      FROM deck_cards dc
      JOIN cards c ON dc.card_id = c.id
      WHERE dc.deck_id = ?
    `;

    const params = [deckId];

    if (query) {
      sqlQuery += ' AND c.name LIKE ?';
      params.push(`%${query}%`);
    }

    if (color) {
      sqlQuery += ' AND c.mana_cost LIKE ?';
      params.push(`%${color}%`);
    }

    if (type) {
      sqlQuery += ' AND c.type_line LIKE ?';
      params.push(`%${type}%`);
    }

    if (isLegendary === 'true') {
      sqlQuery += ' AND c.type_line LIKE ?';
      params.push('%Legendary%');
    }

    if (isLand === 'true') {
      sqlQuery += ' AND c.type_line LIKE ?';
      params.push('%Land%');
    }

    const [deckCardRows] = await pool.execute(sqlQuery, params);

    // Format deck cards
    const filteredCards = deckCardRows.map((row) => ({
      id: row.id,
      cardId: row.card_id,
      count: row.count,
      card: {
        id: row.card_id,
        name: row.name,
        manaCost: row.mana_cost,
        typeLine: row.type_line,
        oracleText: row.oracle_text,
        usd: row.usd,
        usdFoil: row.usd_foil,
        imageUrl: row.image_url,
        setName: row.set_name,
      },
    }));

    return res.json({ deckCards: filteredCards });
  } catch (error) {
    console.error('Error searching deck:', error.message);
    return res.status(500).json({ error: 'Error searching deck' });
  }
};

// Delete a deck
const deleteDeck = async (req, res) => {
  try {
    const { deckId } = req.body;
    const userId = req.user.id;

    if (!deckId) {
      return res.status(400).json({ error: 'Deck ID is required' });
    }

    // Verify deck belongs to user
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    // Delete all cards in the deck first
    await pool.execute('DELETE FROM deck_cards WHERE deck_id = ?', [deckId]);

    // Delete the deck
    await pool.execute('DELETE FROM decks WHERE id = ?', [deckId]);

    return res.json({
      message: 'Deck deleted successfully',
    });
  } catch (error) {
    console.error('Error deleting deck:', error.message);
    return res.status(500).json({ error: 'Error deleting deck' });
  }
};

// Upload a picture for a deck
const uploadDeckPicture = async (req, res) => {
  try {
    const { deckId } = req.params;
    const userId = req.user.id;

    if (!req.file) {
      return res.status(400).json({ error: 'No picture uploaded' });
    }

    // Verify deck belongs to user
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    // Update deck with picture
    await pool.execute('UPDATE decks SET picture = ? WHERE id = ?', [
      req.file.buffer,
      deckId,
    ]);

    return res.json({
      message: 'Deck picture uploaded successfully',
    });
  } catch (error) {
    console.error('Error uploading deck picture:', error.message);
    return res.status(500).json({ error: 'Error uploading deck picture' });
  }
};

// Remove a picture from a deck
const removeDeckPicture = async (req, res) => {
  try {
    const { deckId } = req.params;
    const userId = req.user.id;

    // Verify deck belongs to user
    const [deckRows] = await pool.execute(
      'SELECT * FROM decks WHERE id = ? AND user_id = ?',
      [deckId, userId]
    );

    if (deckRows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }

    // Update deck to remove picture
    await pool.execute('UPDATE decks SET picture = NULL WHERE id = ?', [
      deckId,
    ]);

    return res.json({
      message: 'Deck picture removed successfully',
    });
  } catch (error) {
    console.error('Error removing deck picture:', error.message);
    return res.status(500).json({ error: 'Error removing deck picture' });
  }
};

module.exports = {
  viewDeck,
  filterDeckCards,
  addCardToDeck,
  createDeck,
  removeCardFromDeck,
  verifyDeck,
  searchDeck,
  deleteDeck,
  uploadDeckPicture,
  removeDeckPicture,
};

================
File: controllers/inventoryController.js
================
const { pool } = require('../models/db');

// Add these functions at the top of the inventoryController.js file:

const getCardsSortedByName = (inventoryCards) => {
  return [...inventoryCards].sort((a, b) => {
    const nameA = a.card.name ? a.card.name.toLowerCase() : '';
    const nameB = b.card.name ? b.card.name.toLowerCase() : '';
    return nameA.localeCompare(nameB);
  });
};

const getCardsSortedByManaCost = (inventoryCards) => {
  return [...inventoryCards].sort((a, b) => {
    const costA = a.card.mana_cost ? a.card.mana_cost : '';
    const costB = b.card.mana_cost ? b.card.mana_cost : '';
    return costA.localeCompare(costB);
  });
};

// Then modify the getSortedInventory function:
const getSortedInventory = async (req, res) => {
  try {
    const userId = req.user.id;
    const { sortBy } = req.query;

    // Get inventory cards with card details
    const [inventoryRows] = await pool.execute(
      `SELECT i.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
       FROM inventory i
       JOIN cards c ON i.card_id = c.id
       WHERE i.user_id = ?`,
      [userId]
    );

    // Format inventory cards
    let inventoryCards = inventoryRows.map((row) => ({
      id: row.id,
      cardId: row.card_id,
      quantity: row.quantity,
      condition: row.condition,
      addedAt: row.added_at,
      card: {
        id: row.card_id,
        name: row.name,
        manaCost: row.mana_cost,
        typeLine: row.type_line,
        oracleText: row.oracle_text,
        usd: row.usd,
        usdFoil: row.usd_foil,
        imageUrl: row.image_url,
        setName: row.set_name,
      },
    }));

    // Apply sorting
    if (sortBy === 'name') {
      inventoryCards = getCardsSortedByName(inventoryCards);
    } else if (sortBy === 'mana_cost') {
      inventoryCards = getCardsSortedByManaCost(inventoryCards);
    }

    return res.json({ inventory: inventoryCards });
  } catch (error) {
    console.error('Error getting sorted inventory:', error.message);
    return res.status(500).json({ error: 'Error retrieving sorted inventory' });
  }
};

// Get user's inventory
const getInventory = async (req, res) => {
  try {
    const userId = req.user.id;

    // Get inventory cards with card details
    const [inventoryRows] = await pool.execute(
      `SELECT i.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
       FROM inventory i
       JOIN cards c ON i.card_id = c.id
       WHERE i.user_id = ?`,
      [userId]
    );

    // Format inventory cards
    const inventoryCards = inventoryRows.map((row) => ({
      id: row.id,
      cardId: row.card_id,
      quantity: row.quantity,
      condition: row.condition,
      addedAt: row.added_at,
      card: {
        id: row.card_id,
        name: row.name,
        manaCost: row.mana_cost,
        typeLine: row.type_line,
        oracleText: row.oracle_text,
        usd: row.usd,
        usdFoil: row.usd_foil,
        imageUrl: row.image_url,
        setName: row.set_name,
      },
    }));

    return res.json({ inventory: inventoryCards });
  } catch (error) {
    console.error('Error getting inventory:', error.message);
    return res.status(500).json({ error: 'Error retrieving inventory' });
  }
};

// Search user's inventory
const searchInventory = async (req, res) => {
  try {
    const userId = req.user.id;
    const { query, color, type, isLegendary, isLand } = req.query;

    // Build query to search inventory
    let sqlQuery = `
      SELECT i.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
      FROM inventory i
      JOIN cards c ON i.card_id = c.id
      WHERE i.user_id = ?
    `;

    const params = [userId];

    if (query) {
      sqlQuery += ' AND c.name LIKE ?';
      params.push(`%${query}%`);
    }

    if (color) {
      sqlQuery += ' AND c.mana_cost LIKE ?';
      params.push(`%${color}%`);
    }

    if (type) {
      sqlQuery += ' AND c.type_line LIKE ?';
      params.push(`%${type}%`);
    }

    if (isLegendary === 'true') {
      sqlQuery += ' AND c.type_line LIKE ?';
      params.push('%Legendary%');
    }

    if (isLand === 'true') {
      sqlQuery += ' AND c.type_line LIKE ?';
      params.push('%Land%');
    }

    const [inventoryRows] = await pool.execute(sqlQuery, params);

    // Format inventory cards
    const inventoryCards = inventoryRows.map((row) => ({
      id: row.id,
      cardId: row.card_id,
      quantity: row.quantity,
      condition: row.condition,
      addedAt: row.added_at,
      card: {
        id: row.card_id,
        name: row.name,
        manaCost: row.mana_cost,
        typeLine: row.type_line,
        oracleText: row.oracle_text,
        usd: row.usd,
        usdFoil: row.usd_foil,
        imageUrl: row.image_url,
        setName: row.set_name,
      },
    }));

    return res.json({ cards: inventoryCards });
  } catch (error) {
    console.error('Error searching inventory:', error.message);
    return res.status(500).json({ error: 'Error searching inventory' });
  }
};

// Update card quantity in inventory
const updateCardQuantity = async (req, res) => {
  try {
    const userId = req.user.id;
    const { cardId, quantity } = req.body;

    if (!cardId || !quantity) {
      return res
        .status(400)
        .json({ error: 'Card ID and quantity are required' });
    }

    const quantityNum = parseInt(quantity);

    if (isNaN(quantityNum) || quantityNum <= 0) {
      return res
        .status(400)
        .json({ error: 'Quantity must be a positive number' });
    }

    // Check if card exists in inventory
    const [inventoryRows] = await pool.execute(
      'SELECT * FROM inventory WHERE user_id = ? AND card_id = ?',
      [userId, cardId]
    );

    if (inventoryRows.length === 0) {
      return res.status(404).json({ error: 'Card not found in inventory' });
    }

    // Update quantity
    await pool.execute(
      'UPDATE inventory SET quantity = ? WHERE user_id = ? AND card_id = ?',
      [quantityNum, userId, cardId]
    );

    return res.json({
      message: 'Card quantity updated successfully',
      quantity: quantityNum,
    });
  } catch (error) {
    console.error('Error updating card quantity:', error.message);
    return res.status(500).json({ error: 'Error updating card quantity' });
  }
};

// Remove card from inventory
const removeCard = async (req, res) => {
  try {
    const userId = req.user.id;
    const { cardId } = req.body;

    if (!cardId) {
      return res.status(400).json({ error: 'Card ID is required' });
    }

    // Check if card exists in inventory
    const [inventoryRows] = await pool.execute(
      'SELECT * FROM inventory WHERE user_id = ? AND card_id = ?',
      [userId, cardId]
    );

    if (inventoryRows.length === 0) {
      return res.status(404).json({ error: 'Card not found in inventory' });
    }

    // Remove card from inventory
    await pool.execute(
      'DELETE FROM inventory WHERE user_id = ? AND card_id = ?',
      [userId, cardId]
    );

    return res.json({
      message: 'Card removed from inventory successfully',
    });
  } catch (error) {
    console.error('Error removing card from inventory:', error.message);
    return res
      .status(500)
      .json({ error: 'Error removing card from inventory' });
  }
};

// Get inventory sorted by name or mana cost
const getSortedInventory = async (req, res) => {
  try {
    const userId = req.user.id;
    const { sortBy } = req.query;

    let orderBy = '';

    if (sortBy === 'name') {
      orderBy = 'ORDER BY c.name ASC';
    } else if (sortBy === 'mana_cost') {
      orderBy = 'ORDER BY c.mana_cost ASC';
    }

    // Get inventory cards with card details
    const [inventoryRows] = await pool.execute(
      `SELECT i.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
       FROM inventory i
       JOIN cards c ON i.card_id = c.id
       WHERE i.user_id = ? ${orderBy}`,
      [userId]
    );

    // Format inventory cards
    const inventoryCards = inventoryRows.map((row) => ({
      id: row.id,
      cardId: row.card_id,
      quantity: row.quantity,
      condition: row.condition,
      addedAt: row.added_at,
      card: {
        id: row.card_id,
        name: row.name,
        manaCost: row.mana_cost,
        typeLine: row.type_line,
        oracleText: row.oracle_text,
        usd: row.usd,
        usdFoil: row.usd_foil,
        imageUrl: row.image_url,
        setName: row.set_name,
      },
    }));

    return res.json({ inventory: inventoryCards });
  } catch (error) {
    console.error('Error getting sorted inventory:', error.message);
    return res.status(500).json({ error: 'Error retrieving sorted inventory' });
  }
};

module.exports = {
  getInventory,
  searchInventory,
  updateCardQuantity,
  removeCard,
  getSortedInventory,
};

================
File: controllers/userController.js
================
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { pool } = require('../models/db');
const { JWT_SECRET, JWT_EXPIRY } = require('../config');

const userService = require('../services/userService');
const authService = require('../services/authService');

// Register a new user
const register = async (req, res) => {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res
        .status(400)
        .json({ error: 'Username and password are required' });
    }

    const result = await authService.register(username, password);

    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }

    return res.status(201).json({
      message: 'User registered successfully',
      userId: result.userId,
    });
  } catch (error) {
    console.error('Registration error:', error.message);
    return res.status(500).json({ error: 'Internal server error' });
  }
};

// Login user
const login = async (req, res) => {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res
        .status(400)
        .json({ error: 'Username and password are required' });
    }

    const result = await authService.authenticate(username, password);

    if (!result.success) {
      return res.status(401).json({ error: result.error });
    }

    // Set token in cookie
    res.cookie('token', result.token, {
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
    });

    return res.json({
      message: 'Login successful',
      user: result.user,
      token: result.token,
    });
  } catch (error) {
    console.error('Login error:', error.message);
    return res.status(500).json({ error: 'Internal server error' });
  }
};

// Logout user
const logout = (req, res) => {
  res.clearCookie('token');
  return res.json({ message: 'Logout successful' });
};

// Update user profile picture
const updatePhoto = async (req, res) => {
  try {
    const userId = req.user.id;

    if (!req.file) {
      return res.status(400).json({ error: 'No photo uploaded' });
    }

    // Update user's photo
    await pool.execute('UPDATE users SET photo = ? WHERE id = ?', [
      req.file.buffer,
      userId,
    ]);

    return res.json({
      message: 'Photo updated successfully',
      photo: req.file.buffer.toString('base64'),
    });
  } catch (error) {
    console.error('Update photo error:', error.message);
    return res.status(500).json({ error: 'Internal server error' });
  }
};

// Remove user profile picture
const removePhoto = async (req, res) => {
  try {
    const userId = req.user.id;

    // Remove user's photo
    await pool.execute('UPDATE users SET photo = NULL WHERE id = ?', [userId]);

    return res.json({
      message: 'Photo removed successfully',
    });
  } catch (error) {
    console.error('Remove photo error:', error.message);
    return res.status(500).json({ error: 'Internal server error' });
  }
};

// Get user profile
const getProfile = async (req, res) => {
  try {
    const userId = req.user.id;

    // Get user information
    const [users] = await pool.execute(
      'SELECT id, username, photo, created_at FROM users WHERE id = ?',
      [userId]
    );

    if (users.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const user = users[0];

    return res.json({
      user: {
        id: user.id,
        username: user.username,
        photo: user.photo ? user.photo.toString('base64') : null,
        createdAt: user.created_at,
      },
    });
  } catch (error) {
    console.error('Get profile error:', error.message);
    return res.status(500).json({ error: 'Internal server error' });
  }
};

module.exports = {
  register,
  login,
  logout,
  updatePhoto,
  removePhoto,
  getProfile,
};

================
File: middleware/auth.js
================
// In middleware/auth.js
const authService = require('../services/authService');

const authenticate = (req, res, next) => {
  const token = req.cookies.token || req.headers.authorization?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  const result = authService.verifyToken(token);

  if (!result.valid) {
    return res.status(401).json({ error: 'Invalid token' });
  }

  req.user = result.user;
  next();
};

module.exports = {
  authenticate,
};

================
File: models/db.js
================
const mysql = require('mysql2/promise');
const { DB } = require('../config');

// Create a connection pool
const pool = mysql.createPool({
  host: DB.host,
  port: DB.port,
  user: DB.user,
  password: DB.password,
  database: DB.database,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});

// Test database connection
const testConnection = async () => {
  try {
    const connection = await pool.getConnection();
    console.log('Database connection established successfully');
    connection.release();
    return true;
  } catch (error) {
    console.error('Database connection failed:', error.message);
    return false;
  }
};

// Initialize database tables
const initDatabase = async () => {
  try {
    // Create users table if not exists
    await pool.execute(`
      CREATE TABLE IF NOT EXISTS users (
        id INT AUTO_INCREMENT PRIMARY KEY,
        username VARCHAR(255) NOT NULL UNIQUE,
        password VARCHAR(255) NOT NULL,
        photo LONGBLOB,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create cards table if not exists

    // In models/db.js, update the cards table creation:

    await pool.execute(`
      CREATE TABLE IF NOT EXISTS cards (
        id VARCHAR(255) PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        mana_cost VARCHAR(255),
        type_line VARCHAR(255),
        oracle_text TEXT,
        usd VARCHAR(50),
        usd_foil VARCHAR(50),
        image_url VARCHAR(255),
        set_name VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create inventory table if not exists
    await pool.execute(`
      CREATE TABLE IF NOT EXISTS inventory (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        card_id VARCHAR(255) NOT NULL,
        card_name VARCHAR(255) NOT NULL,
        set_name VARCHAR(255),
        price DECIMAL(10, 2),
        quantity INT DEFAULT 1,
        condition VARCHAR(50) DEFAULT 'Near Mint',
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        FOREIGN KEY (card_id) REFERENCES cards(id) ON DELETE CASCADE
      )
    `);

    // Create decks table if not exists
    await pool.execute(`
      CREATE TABLE IF NOT EXISTS decks (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        user_id INT NOT NULL,
        picture LONGBLOB,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `);

    // Create deck_cards table if not exists
    await pool.execute(`
      CREATE TABLE IF NOT EXISTS deck_cards (
        id INT AUTO_INCREMENT PRIMARY KEY,
        deck_id INT NOT NULL,
        card_id VARCHAR(255) NOT NULL,
        count INT DEFAULT 1,
        FOREIGN KEY (deck_id) REFERENCES decks(id) ON DELETE CASCADE,
        FOREIGN KEY (card_id) REFERENCES cards(id) ON DELETE CASCADE,
        UNIQUE KEY deck_card (deck_id, card_id)
      )
    `);

    console.log('Database tables initialized successfully');
  } catch (error) {
    console.error('Error initializing database tables:', error.message);
    throw error;
  }
};

module.exports = {
  pool,
  testConnection,
  initDatabase,
};

================
File: models/index.js
================
// In-memory database (for demonstration purposes)
const users = [];
const inventories = {};

module.exports = {
  users,
  inventories
};

================
File: repositories/cardRepository.js
================
const { pool } = require('../models/db');

// Find card by ID
const findById = async (id) => {
  const [rows] = await pool.execute('SELECT * FROM cards WHERE id = ?', [id]);
  return rows.length > 0 ? rows[0] : null;
};

// Find card by name
const findByName = async (name) => {
  const [rows] = await pool.execute('SELECT * FROM cards WHERE name = ?', [
    name,
  ]);
  return rows.length > 0 ? rows[0] : null;
};

// Save card
const save = async (card) => {
  const {
    id,
    name,
    mana_cost,
    type_line,
    oracle_text,
    usd,
    usd_foil,
    image_url,
    set_name,
  } = card;

  await pool.execute(
    `INSERT INTO cards 
     (id, name, mana_cost, type_line, oracle_text, usd, usd_foil, image_url, set_name) 
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
     ON DUPLICATE KEY UPDATE
     name = VALUES(name),
     mana_cost = VALUES(mana_cost),
     type_line = VALUES(type_line),
     oracle_text = VALUES(oracle_text),
     usd = VALUES(usd),
     usd_foil = VALUES(usd_foil),
     image_url = VALUES(image_url),
     set_name = VALUES(set_name)`,
    [
      id,
      name,
      mana_cost,
      type_line,
      oracle_text,
      usd,
      usd_foil,
      image_url,
      set_name,
    ]
  );

  return card;
};

module.exports = {
  findById,
  findByName,
  save,
};

================
File: repositories/deckRepository.js
================
const { pool } = require('../models/db');

// Find deck by ID
const findById = async (deckId) => {
  const [rows] = await pool.execute('SELECT * FROM decks WHERE id = ?', [
    deckId,
  ]);
  return rows.length > 0 ? rows[0] : null;
};

// Find decks by user ID
const findByUserId = async (userId) => {
  const [rows] = await pool.execute('SELECT * FROM decks WHERE user_id = ?', [
    userId,
  ]);
  return rows;
};

// Create new deck
const create = async (name, userId) => {
  const [result] = await pool.execute(
    'INSERT INTO decks (name, user_id, created_at) VALUES (?, ?, NOW())',
    [name, userId]
  );

  return { id: result.insertId, name, userId };
};

// Update deck
const update = async (deck) => {
  await pool.execute('UPDATE decks SET name = ?, picture = ? WHERE id = ?', [
    deck.name,
    deck.picture,
    deck.id,
  ]);
  return deck;
};

// Delete deck
const deleteById = async (deckId) => {
  // First delete all cards in the deck
  await pool.execute('DELETE FROM deck_cards WHERE deck_id = ?', [deckId]);

  // Then delete the deck
  await pool.execute('DELETE FROM decks WHERE id = ?', [deckId]);
};

// Get deck cards
const getDeckCards = async (deckId) => {
  const [rows] = await pool.execute(
    `SELECT dc.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
     FROM deck_cards dc
     JOIN cards c ON dc.card_id = c.id
     WHERE dc.deck_id = ?`,
    [deckId]
  );

  return rows;
};

// Add card to deck
const addCard = async (deckId, cardId) => {
  // Check if card already exists in deck
  const [existingRows] = await pool.execute(
    'SELECT * FROM deck_cards WHERE deck_id = ? AND card_id = ?',
    [deckId, cardId]
  );

  if (existingRows.length > 0) {
    // Increment count if card already exists in deck
    await pool.execute(
      'UPDATE deck_cards SET count = count + 1 WHERE deck_id = ? AND card_id = ?',
      [deckId, cardId]
    );
    return { ...existingRows[0], count: existingRows[0].count + 1 };
  } else {
    // Add new card to deck
    const [result] = await pool.execute(
      'INSERT INTO deck_cards (deck_id, card_id, count) VALUES (?, ?, 1)',
      [deckId, cardId]
    );

    return { id: result.insertId, deckId, cardId, count: 1 };
  }
};

// Remove card from deck
const removeCard = async (deckId, cardId) => {
  // Get current count
  const [countRows] = await pool.execute(
    'SELECT count FROM deck_cards WHERE deck_id = ? AND card_id = ?',
    [deckId, cardId]
  );

  if (countRows.length === 0) {
    return { found: false };
  }

  const count = countRows[0].count;

  if (count > 1) {
    // Decrement count
    await pool.execute(
      'UPDATE deck_cards SET count = count - 1 WHERE deck_id = ? AND card_id = ?',
      [deckId, cardId]
    );
    return { found: true, removed: false, newCount: count - 1 };
  } else {
    // Remove card completely
    await pool.execute(
      'DELETE FROM deck_cards WHERE deck_id = ? AND card_id = ?',
      [deckId, cardId]
    );
    return { found: true, removed: true };
  }
};

module.exports = {
  findById,
  findByUserId,
  create,
  update,
  deleteById,
  getDeckCards,
  addCard,
  removeCard,
};

================
File: repositories/inventoryRepository.js
================
const { pool } = require('../models/db');

// Get inventory by user ID
const findByUserId = async (userId) => {
  const [rows] = await pool.execute(
    `SELECT i.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
     FROM inventory i
     JOIN cards c ON i.card_id = c.id
     WHERE i.user_id = ?`,
    [userId]
  );

  return rows;
};

// Add card to inventory
const addCard = async (userId, cardId, cardName, setName, price) => {
  // Check if card already exists in inventory
  const [existingRows] = await pool.execute(
    'SELECT * FROM inventory WHERE user_id = ? AND card_id = ?',
    [userId, cardId]
  );

  if (existingRows.length > 0) {
    // Increment quantity if card already in inventory
    await pool.execute(
      'UPDATE inventory SET quantity = quantity + 1 WHERE user_id = ? AND card_id = ?',
      [userId, cardId]
    );
    return existingRows[0];
  } else {
    // Add new card to inventory
    const [result] = await pool.execute(
      `INSERT INTO inventory 
       (user_id, card_id, card_name, set_name, price, quantity, condition, added_at) 
       VALUES (?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        userId,
        cardId,
        cardName,
        setName || null,
        price || null,
        1, // Default quantity
        'Near Mint', // Default condition
      ]
    );

    return { id: result.insertId, cardId, quantity: 1 };
  }
};

// Update card quantity
const updateCardQuantity = async (userId, cardId, quantity) => {
  await pool.execute(
    'UPDATE inventory SET quantity = ? WHERE user_id = ? AND card_id = ?',
    [quantity, userId, cardId]
  );
};

// Remove card from inventory
const removeCard = async (userId, cardId) => {
  await pool.execute(
    'DELETE FROM inventory WHERE user_id = ? AND card_id = ?',
    [userId, cardId]
  );
};

// Get inventory sorted by field
const getSorted = async (userId, sortBy) => {
  let orderBy = '';

  if (sortBy === 'name') {
    orderBy = 'ORDER BY c.name ASC';
  } else if (sortBy === 'mana_cost') {
    orderBy = 'ORDER BY c.mana_cost ASC';
  }

  const [rows] = await pool.execute(
    `SELECT i.*, c.name, c.mana_cost, c.type_line, c.oracle_text, c.usd, c.usd_foil, c.image_url, c.set_name 
     FROM inventory i
     JOIN cards c ON i.card_id = c.id
     WHERE i.user_id = ? ${orderBy}`,
    [userId]
  );

  return rows;
};

module.exports = {
  findByUserId,
  addCard,
  updateCardQuantity,
  removeCard,
  getSorted,
};

================
File: repositories/userRepository.js
================
const { pool } = require('../models/db');

// Find all users
const findAll = async () => {
  const [rows] = await pool.execute('SELECT * FROM users');
  return rows;
};

// Find user by ID
const findById = async (id) => {
  const [rows] = await pool.execute('SELECT * FROM users WHERE id = ?', [id]);
  return rows.length > 0 ? rows[0] : null;
};

// Find user by username
const findByUsername = async (username) => {
  const [rows] = await pool.execute('SELECT * FROM users WHERE username = ?', [
    username,
  ]);
  return rows.length > 0 ? rows[0] : null;
};

// Save user
const save = async (user) => {
  if (user.id) {
    // Update existing user
    await pool.execute(
      'UPDATE users SET username = ?, password = ?, photo = ? WHERE id = ?',
      [user.username, user.password, user.photo, user.id]
    );
  } else {
    // Create new user
    const [result] = await pool.execute(
      'INSERT INTO users (username, password, created_at) VALUES (?, ?, NOW())',
      [user.username, user.password]
    );
    user.id = result.insertId;
  }
  return user;
};

// Delete user by ID
const deleteById = async (id) => {
  await pool.execute('DELETE FROM users WHERE id = ?', [id]);
};

module.exports = {
  findAll,
  findById,
  findByUsername,
  save,
  deleteById,
};

================
File: routes/cardRoutes.js
================
const express = require('express');
const { 
  getSearchFilters, 
  searchCards, 
  getPaginatedResults, 
  getCardById, 
  addCardToInventory 
} = require('../controllers/cardController');
const { authenticate } = require('../middleware/auth');

const router = express.Router();

// Public routes
router.get('/search/filters', getSearchFilters);
router.get('/search', searchCards);
router.get('/search/page/:page', getPaginatedResults);
router.get('/cards/:cardId', getCardById);

// Protected routes
router.post('/add_card_to_inventory', authenticate, addCardToInventory);

module.exports = router;

================
File: routes/deckRoutes.js
================
const express = require('express');
const multer = require('multer');
const { 
  viewDeck,
  filterDeckCards,
  addCardToDeck,
  createDeck,
  removeCardFromDeck,
  verifyDeck,
  searchDeck,
  deleteDeck,
  uploadDeckPicture,
  removeDeckPicture
} = require('../controllers/deckController');
const { authenticate } = require('../middleware/auth');

const router = express.Router();
const upload = multer({ storage: multer.memoryStorage() });

// All deck routes require authentication
router.use(authenticate);

// Get deck by ID
router.get('/deck/:deckId', viewDeck);

// Filter deck cards
router.get('/deck/:deckId/filter', filterDeckCards);

// Add card to deck
router.post('/add_card_to_deck', addCardToDeck);

// Create a new deck
router.post('/create_deck', createDeck);

// Remove card from deck
router.delete('/deck/:deckId/remove_card', removeCardFromDeck);

// Verify if deck has at least 5 cards
router.get('/deck/:deckId/verify', verifyDeck);

// Search for cards in deck
router.get('/deck/:deckId/search', searchDeck);

// Delete a deck
router.delete('/delete_deck', deleteDeck);

// Upload deck picture
router.post('/deck/:deckId/upload_picture', upload.single('deckPicture'), uploadDeckPicture);

// Remove deck picture
router.delete('/deck/:deckId/remove_picture', removeDeckPicture);

module.exports = router;

================
File: routes/index.js
================
const express = require('express');
const userRoutes = require('./userRoutes');
const cardRoutes = require('./cardRoutes');
const inventoryRoutes = require('./inventoryRoutes');
const deckRoutes = require('./deckRoutes');

const router = express.Router();

// Mount route groups
router.use('/users', userRoutes);
router.use('/cards', cardRoutes);
router.use('/inventory', inventoryRoutes);
router.use('/decks', deckRoutes);

module.exports = router;

================
File: routes/inventoryRoutes.js
================
const express = require('express');
const { 
  getInventory, 
  searchInventory, 
  updateCardQuantity, 
  removeCard,
  getSortedInventory
} = require('../controllers/inventoryController');
const { authenticate } = require('../middleware/auth');

const router = express.Router();

// All inventory routes require authentication
router.use(authenticate);

// Get user's inventory
router.get('/inventory', getInventory);

// Get sorted inventory
router.get('/inventory/sorted', getSortedInventory);

// Search inventory
router.get('/search_inventory', searchInventory);

// Update card quantity
router.put('/update_quantity', updateCardQuantity);

// Remove card from inventory
router.delete('/remove_card', removeCard);

module.exports = router;

================
File: routes/userRoutes.js
================
const express = require('express');
const multer = require('multer');
const { 
  register, 
  login, 
  logout, 
  updatePhoto,
  removePhoto,
  getProfile
} = require('../controllers/userController');
const { authenticate } = require('../middleware/auth');

const router = express.Router();
const upload = multer({ storage: multer.memoryStorage() });

// Public routes
router.post('/register', register);
router.post('/login', login);
router.post('/logout', logout);

// Protected routes
router.get('/profile', authenticate, getProfile);
router.post('/update_photo', authenticate, upload.single('photo'), updatePhoto);
router.delete('/remove_photo', authenticate, removePhoto);

module.exports = router;

================
File: services/authService.js
================
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { JWT_SECRET, JWT_EXPIRY } = require('../config');
const userRepository = require('../repositories/userRepository');

class AuthService {
  // Authenticate user and generate JWT token
  async authenticate(username, password) {
    const user = await userRepository.findByUsername(username);

    if (!user) {
      return { success: false, error: 'Invalid credentials' };
    }

    const isPasswordValid = await bcrypt.compare(password, user.password);

    if (!isPasswordValid) {
      return { success: false, error: 'Invalid credentials' };
    }

    // Generate JWT token
    const token = jwt.sign(
      { id: user.id, username: user.username },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRY }
    );

    return {
      success: true,
      user: {
        id: user.id,
        username: user.username,
        photo: user.photo ? user.photo.toString('base64') : null,
      },
      token,
    };
  }

  // Register a new user
  async register(username, password) {
    // Check if user already exists
    const existingUser = await userRepository.findByUsername(username);

    if (existingUser) {
      return { success: false, error: 'Username already exists' };
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create new user
    const user = await userRepository.save({
      username,
      password: hashedPassword,
    });

    return {
      success: true,
      userId: user.id,
    };
  }

  // Verify JWT token
  verifyToken(token) {
    try {
      const decoded = jwt.verify(token, JWT_SECRET);
      return { valid: true, user: decoded };
    } catch (error) {
      return { valid: false, error: 'Invalid token' };
    }
  }
}

module.exports = new AuthService();

================
File: services/cardService.js
================
const axios = require('axios');
const cardRepository = require('../repositories/cardRepository');

class CardService {
  constructor() {
    this.REQUEST_DELAY_MS = 100;
  }

  // Helper function to delay requests
  async delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  // Fetch card data for multiple cards at once (like CardService.java's fetchCardsData)
  async fetchCardsData(inventoryCards) {
    const identifiers = inventoryCards.map((ic) => ({ id: ic.cardId }));

    try {
      const url = 'https://api.scryfall.com/cards/collection';
      const headers = { 'Content-Type': 'application/json' };

      await this.delay(this.REQUEST_DELAY_MS);
      const response = await axios.post(url, { identifiers }, { headers });

      // Create map from response data
      const idToCardMap = {};
      if (response.data && response.data.data) {
        response.data.data.forEach((cardData) => {
          const card = this.createCardFromResponseData(cardData);
          idToCardMap[card.id] = card;
        });
      }

      return idToCardMap;
    } catch (error) {
      console.error('Error fetching card collection data:', error.message);
      return {};
    }
  }

  // Find card by ID
  async findById(id) {
    return cardRepository.findById(id);
  }

  // Find card by name
  async findByName(name) {
    return cardRepository.findByName(name);
  }

  // Save card to database
  async save(card) {
    return cardRepository.save(card);
  }

  // Delete card from database
  async deleteById(id) {
    return cardRepository.deleteById(id);
  }

  // Helper to create card object from API response
  createCardFromResponseData(cardData) {
    const card = {
      id: cardData.id,
      name: cardData.name,
      mana_cost: cardData.mana_cost,
      type_line: cardData.type_line,
      oracle_text: cardData.oracle_text,
      usd: cardData.prices?.usd || null,
      usd_foil: cardData.prices?.usd_foil || null,
      image_url: cardData.image_uris?.normal || null,
      set_name: cardData.set_name || null,
    };

    // Log warning if card ID is null
    if (!card.id) {
      console.warn('Warning: Card ID is null for card:', cardData.name);
    }

    return card;
  }
}

module.exports = new CardService();

================
File: services/deckService.js
================
const deckRepository = require('../repositories/deckRepository');
const cardRepository = require('../repositories/cardRepository');

class DeckService {
  // Find deck by ID
  async findById(deckId) {
    return deckRepository.findById(deckId);
  }

  // Find decks by user ID
  async findByUserId(userId) {
    return deckRepository.findByUserId(userId);
  }

  // Create new deck
  async create(name, userId) {
    return deckRepository.create(name, userId);
  }

  // Update deck
  async update(deck) {
    return deckRepository.update(deck);
  }

  // Delete deck
  async deleteById(deckId) {
    return deckRepository.deleteById(deckId);
  }

  // Get deck cards
  async getDeckCards(deckId) {
    return deckRepository.getDeckCards(deckId);
  }

  // Add card to deck
  async addCard(deckId, cardId) {
    return deckRepository.addCard(deckId, cardId);
  }

  // Remove card from deck
  async removeCard(deckId, cardId) {
    return deckRepository.removeCard(deckId, cardId);
  }

  // Verify if deck is valid (has at least 5 cards)
  async verifyDeck(deckId) {
    const deckCards = await deckRepository.getDeckCards(deckId);

    const totalCards = deckCards.reduce((total, card) => total + card.count, 0);

    return {
      isValid: totalCards >= 5,
      totalCards,
      message:
        totalCards >= 5
          ? 'Deck is valid. It has at least 5 cards.'
          : 'Deck is invalid. It must have at least 5 cards.',
    };
  }

  // Search for cards in deck
  async searchDeckCards(deckId, query, color, type, isLegendary, isLand) {
    const deckCards = await deckRepository.getDeckCards(deckId);

    return deckCards.filter((card) => {
      let matches = true;

      if (query) {
        matches =
          matches && card.name.toLowerCase().includes(query.toLowerCase());
      }

      if (color) {
        matches = matches && card.mana_cost && card.mana_cost.includes(color);
      }

      if (type) {
        matches =
          matches &&
          card.type_line &&
          card.type_line.toLowerCase().includes(type.toLowerCase());
      }

      if (isLegendary) {
        matches =
          matches &&
          card.type_line &&
          card.type_line.toLowerCase().includes('legendary');
      }

      if (isLand) {
        matches =
          matches &&
          card.type_line &&
          card.type_line.toLowerCase().includes('land');
      }

      return matches;
    });
  }
}

module.exports = new DeckService();

================
File: services/inventoryService.js
================
const inventoryRepository = require('../repositories/inventoryRepository');

class InventoryService {
  // Find inventory by user ID
  async findByUserId(userId) {
    return inventoryRepository.findByUserId(userId);
  }

  // Add card to inventory
  async addCard(userId, cardId, cardName, setName, price) {
    return inventoryRepository.addCard(
      userId,
      cardId,
      cardName,
      setName,
      price
    );
  }

  // Update card quantity
  async updateCardQuantity(userId, cardId, quantity) {
    return inventoryRepository.updateCardQuantity(userId, cardId, quantity);
  }

  // Remove card from inventory
  async removeCard(userId, cardId) {
    return inventoryRepository.removeCard(userId, cardId);
  }

  // Get sorted inventory
  async getSorted(userId, sortBy) {
    return inventoryRepository.getSorted(userId, sortBy);
  }
}

module.exports = new InventoryService();

================
File: services/userService.js
================
const userRepository = require('../repositories/userRepository');
const inventoryService = require('./inventoryService');

class UserService {
  // Find all users
  async findAll() {
    return userRepository.findAll();
  }

  // Find user by ID
  async findById(id) {
    return userRepository.findById(id);
  }

  // Find user by username
  async findByUsername(username) {
    return userRepository.findByUsername(username);
  }

  // Check if user exists
  async userExists(username) {
    const user = await userRepository.findByUsername(username);
    return !!user;
  }

  // Save user
  async save(user) {
    // In a real world application, we would also save associated inventory here
    // For now, we'll just handle the basic user save operation
    return userRepository.save(user);
  }

  // Delete user by ID
  async deleteById(id) {
    // In a real world application, we would handle related entities like inventory
    return userRepository.deleteById(id);
  }
}

module.exports = new UserService();

================
File: .gitignore
================
node_modules

================
File: index.js
================
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const { PORT } = require('./config');
const apiRoutes = require('./routes');
const { testConnection, initDatabase } = require('./models/db');
require('dotenv').config();

// Initialize Express app
const app = express();

// Middleware
app.use(cors());
app.use(bodyParser.json());
app.use(cookieParser());

// Root route for health check
app.get('/', (req, res) => {
  res.json({ message: 'Magic Inventory API is running' });
});

// Mount API router
app.use('/api', apiRoutes);

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

// Initialize database and start server
const startServer = async () => {
  try {
    // Test database connection
    const isConnected = await testConnection();
    
    if (isConnected) {
      // Initialize database tables
      await initDatabase();
      
      // Start server
      app.listen(PORT, () => {
        console.log(`Magic Inventory API server running on port ${PORT}`);
        console.log(`API base URL: http://localhost:${PORT}/api`);
      });
    } else {
      console.error('Failed to start server due to database connection issues');
    }
  } catch (error) {
    console.error('Server initialization error:', error);
  }
};

startServer();

================
File: package.json
================
{
  "name": "magic-inventory-api",
  "version": "1.0.0",
  "description": "Magic Inventory API Server",
  "main": "index.js",
  "private": true,
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "express": "^4.18.2",
    "body-parser": "^1.20.2",
    "cors": "^2.8.5",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "cookie-parser": "^1.4.6",
    "dotenv": "^16.3.1",
    "mysql2": "^3.6.5",
    "axios": "^1.6.2",
    "node-cache": "^5.1.2",
    "multer": "^1.4.5-lts.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}



================================================================
End of Codebase
================================================================
